# BizAssist Monorepo — Source of Truth (.ai-context.md)

## 0) High-level goal

Build a Telegram bot + (later) Telegram WebApp for tax assistance in Kyrgyzstan:

- MVP: onboarding (ИНН + быстрый выбор режима), tax calculator (initially simple), reminders, history.
- Product mindset: fast value, safe defaults, gradual expansion without rewrites.

## 1) Monorepo structure (must respect)

This repository is a pnpm monorepo.

Folders (check these first):

- `apps/api/` — backend REST API (Fastify). Entry: `apps/api/src/main.ts` or `apps/api/src/index.ts` (see which one is used).
- `apps/bot/` — Telegram bot (grammY). Entry: `apps/bot/src/index.ts`.
- `apps/web/` — React + TypeScript + Vite frontend (later Telegram WebApp).
- `packages/db/` — Prisma Client wrapper (shared DB access).
- `packages/core/` — shared business logic, tax rules, Zod schemas, utilities (NO UI).
- `prisma/` — `schema.prisma`, migrations, seed (`prisma/seed.ts`).
- root — `.env`, `docker-compose.yml`, `pnpm-workspace.yaml`, root `package.json`.

## 2) Runtime & tooling

- Language: TypeScript everywhere.
- Package manager: pnpm (workspaces).
- Database: PostgreSQL via Docker (`docker-compose.yml`).
- ORM: Prisma.
- Validation: Zod (primarily in API; shared schemas may live in `packages/core`).
- Bot: grammY.
- Web: React 18 + Vite + TS, TailwindCSS, React Query.

## 3) The “golden rules” for changes (AI must follow)

1. Do NOT introduce new frameworks unless explicitly asked (keep backend simple).
2. Prefer small incremental changes (avoid giant refactors).
3. Before proposing changes, read existing files that are involved.
4. If you change a contract (types, env vars, routes), update ALL affected places.
5. Always return COMPLETE files when asked for code.
6. Do not break existing scripts. If a breaking change is needed, provide a migration plan.
7. Keep business logic in `packages/core`, DB access in `packages/db`, API orchestration in `apps/api`, UI in `apps/web`, bot flow in `apps/bot`.

## 4) Where to look depending on the problem

- Prisma / DB / migrations:
  - `prisma/schema.prisma`
  - `prisma/migrations/**`
  - root `.env`
  - `docker-compose.yml`
  - `packages/db/index.ts`
- API routes, validation, contracts:
  - `apps/api/src/index.ts` and/or `apps/api/src/main.ts`
- Bot flow, keyboards, user onboarding:
  - `apps/bot/src/index.ts`
- Shared calculations & rules:
  - `packages/core/**`
- Frontend (WebApp):
  - `apps/web/**`

## 5) ## Environment variables policy

- Local dev uses per-app env files:
  - `apps/api/.env`
  - `apps/bot/.env`
  - `apps/web/.env` (later)
- Root `.env` may exist for shared defaults, but apps should not rely on it implicitly.
- Never commit real secrets. Use `.env.example`.

## 6) Coding standards (Senior-level)

### Backend (Fastify)

- Use explicit Zod schemas for request validation.
- Use clear HTTP status codes and readable error messages.
- Prefer early returns.
- Separate concerns:
  - route handler: parse/validate + call service
  - service (in `packages/core` or `apps/api/src/services`): business logic
  - db (in `packages/db`): Prisma calls
- No “magic strings” for enums — reuse shared types/constants.
- Add minimal logging where it matters (startup, external calls, errors).

### Bot (grammY)

- Keep bot commands predictable: `/start`, `/help`, `/history`, `/calc`.
- Use small handlers and helper functions.
- Never block the event loop with heavy calculations.
- Keep state minimal; store user profile + history in DB.
- Provide user-friendly error messages.

### Frontend (React)

- Functional components only, hooks-first.
- Feature-based folder structure, no prop drilling (React Query / Context).
- Keep UI dumb; move business logic to hooks/services.
- Always handle loading/error states.
- Types are explicit; avoid `any`.

## 7) How to work with AI (process)

When asking AI to implement or fix something:

- Provide the exact error text (copy from terminal).
- Mention which app you ran (`api`, `bot`, `web`) and the command.
- Ask for: “give me the exact file changes” and “full file outputs”.

AI should respond with:

1. Root cause (1–3 bullets).
2. Fix plan (ordered steps).
3. Updated full files (only the ones that must change).
4. Commands to run to verify.

## 8) Debugging & fixing errors — mandatory order

Always fix in this order (do not skip):

1. Infrastructure:
   - `docker compose up -d`
   - confirm Postgres is reachable (port 5432)
2. Prisma:
   - `pnpm prisma:generate`
   - `pnpm prisma:migrate`
3. API:
   - start API, verify `/health`
4. Bot:
   - start bot, run `/start`
5. Web:
   - start web, verify basic build

If something breaks:

- Do NOT “patch randomly”.
- Identify mismatch between docker-compose credentials and `.env`.
- Ensure workspace package resolution is correct (pnpm workspace dependencies).

## 9) Non-goals (for now)

- No payment gateway integration until MVP proves demand.
- No “auto-detect tax regime by INN” unless we have reliable data source. MVP can use:
  - INN input + 2–3 clarifying questions -> regime choice.
  - Later integrate official/partner sources if available.

## 10) Current MVP scope

- User onboarding (Telegram): INN (optional) + choose regime.
- Calculation: start with simple formulas; architecture must allow plugging real rules later.
- History: store calculations.
- Reminders: next iteration (Redis can be used later for jobs/queues).

## 11) Instruction for AI when asked “fix errors now”

When the user says “fix errors”, AI must:

- Ask for OR infer: which command fails and paste error output (if already provided).
- Then apply minimal changes to restore green state:
  - align `.env` with docker-compose (user/pass/db)
  - ensure Prisma migrate works
  - ensure workspace imports (`@bizassist/db`) resolve
- Provide exact run commands to confirm.

## Senior Output Contract

When writing code:

- Prefer simple, production-ready solutions
- Keep functions small and named clearly
- Use explicit types (no any)
- Validate inputs with Zod (API)
- Avoid breaking changes
- Provide full files, not snippets
- Include a short “How to verify” section with exact commands

## Language & Communication

- All requests and answers must be in Russian.
- Explain briefly and clearly, without unnecessary theory.
- When fixing bugs: first show the root cause, then the minimal fix, then full updated file(s), then commands to verify.
- Code comments: Russian (only where useful).
